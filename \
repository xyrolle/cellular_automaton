const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const tickButton = document.getElementById("tick");
const autoplayButton = document.getElementById("autoplay");

const ROWS = 50;
const COLS = 50;

const CELL_HEIGHT = 25;
const CELL_WIDTH = 25;

const CANVAS_WIDTH = CELL_WIDTH*COLS;
const CANVAS_HEIGHT = CELL_HEIGHT*ROWS;

// Set canvas dimensions
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

// Set canvas background color
ctx.fillStyle = "#000000";
ctx.fillRect(0, 0, canvas.width, canvas.height);

ctx.fillStyle = "#FFFFFF";
ctx.lineWidth = 2;

const grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => ({
  alive: false
})));

const render = (grid) => {
  grid.forEach((rowCells, row) => {
    rowCells.forEach((cell, col) => {
      if (cell.alive) {
        ctx.fillStyle = "#FFFFFF";
      } else {
        ctx.fillStyle = "#000000";
      }

      ctx.fillRect(col*CELL_WIDTH + 1, row*CELL_HEIGHT + 1, CELL_WIDTH - 1, CELL_HEIGHT - 1);
    });
  });
};

const tick = (grid) => {
  const gridCopy = Array.from({length: ROWS}, (_, row) => {
    return grid[row].map(cell => ({...cell}));
  });

  gridCopy.forEach((rowCells, row) => {
    rowCells.forEach((cell, col) => {
      const neighbours = moorsNeighbourhood1(gridCopy, row, col);
      const liveNeighboursCount = neighbours.reduce((prev, curr) => prev += curr.alive, 0);

      // A dead cell will be brought back to live if it has exactly three live neighbors.
      if (!cell.alive && liveNeighboursCount === 3) {
        grid[row][col] = {alive: true};
      } 

      // A live cell dies if it has fewer than two live neighbors.
      if (cell.alive && liveNeighboursCount < 2) {
        grid[row][col] = {alive: false};
      }

      // A live cell with two or three live neighbors lives on to the next generation.
      if (cell.alive && liveNeighboursCount > 3) {
        grid[row][col] = {alive: false};
      }
    });
  });

  render(grid);
};

const mod = (a, b) => (a % b + b) % b;

const moorsNeighbourhood1 = (board, x0, y0) => {
  const neighbours = Array.from({length: 8});

  let index = 0;
  for (let dy = -1; dy <= 1; ++dy) {
    for (let dx = -1; dx <= 1; ++dx) {
      if (dy != 0 || dx != 0) {
        const y = mod(y0 + dy, ROWS);
        const x = mod(x0 + dx, COLS);
        neighbours[index++] = board[x][y];
      }
    }
  }
  
  return neighbours;
}

const moorsNeighbourhood = (grid, row, col) => { 
  const neighbours = [];
  
  const prevRow = (row - 1) < 0 ? ROWS - 1 : row - 1;
  const prevCol = (col - 1) < 0 ? COLS - 1 : col - 1;

  const nextRow = (row + 1) === ROWS ? 0 : row + 1;
  const nextCol = (col + 1) === COLS ? 0 : col + 1; 

  neighbours.push(grid[prevRow][prevCol]);
  neighbours.push(grid[prevRow][col]);
  neighbours.push(grid[prevRow][nextCol]);

  neighbours.push(grid[row][prevCol]);
  neighbours.push(grid[row][nextCol]);
 
  neighbours.push(grid[nextRow][prevCol]);
  neighbours.push(grid[nextRow][col]);
  neighbours.push(grid[nextRow][nextCol]);

  return neighbours;
};

const handleMouseMove = (e) => {
  const {top, left} = e.target.getBoundingClientRect();

  const x = e.clientX - left;
  const y = e.clientY - top;

  const row = Math.floor(y/CELL_HEIGHT);
  const col = Math.floor(x/CELL_WIDTH);

  grid[row][col] = {alive: true};

  render(grid);
}

canvas.addEventListener("mousedown", (e) => {
  canvas.addEventListener("mousemove", handleMouseMove);

});

tickButton.addEventListener("click", () => {
  tick(grid); 
});

let autoplayInterval;
autoplayButton.addEventListener("click", (e) => {
  console.log(autoplayInterval)
  if (autoplayInterval) {
    clearInterval(autoplayInterval);
    autoplayInterval = null;
    autoplayButton.textContent = "autoplay on";
  } else {
    autoplayInterval = setInterval(() => tick(grid), 500);
    autoplayButton.textContent = "autoplay off";
  }
})

